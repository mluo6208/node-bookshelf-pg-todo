'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.World = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp;

var _three = require('three');

var _index = require('../physics/index.js');

var Physijs = _interopRequireWildcard(_index);

var _index2 = require('../utils/index');

var _PerspectiveCamera = require('../components/cameras/PerspectiveCamera');

var _BasicRendering = require('../components/rendering/basic/BasicRendering');

var _Component2 = require('./Component');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var World = (_temp = _class = function (_Component) {
  (0, _inherits3.default)(World, _Component);

  function World() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, World);

    World.defaults.width = window.innerWidth;
    World.defaults.height = window.innerHeight;
    World.defaults.container = window.document.body;

    var _this = (0, _possibleConstructorReturn3.default)(this, (World.__proto__ || Object.getPrototypeOf(World)).call(this, params, World.defaults, World.instructions));

    _this.simulate = false;
    _this.loops = [];
    _this.type = 'world';


    if (__VERSION__) console.log('WhitestormJS Framework v' + __VERSION__);else console.log('WhitestormJS Framework v' + require('../../../package.json').version);

    var _params = _this.params,
        _initParams = _params.init;

    // INIT.
    _this._initDOM(window);
    if (_initParams.scene) _this._initScene();

    if (_initParams.scene && _initParams.camera) _this._initCamera(window);
    if (_initParams.scene && _initParams.rendering) _this._initRendering();
    if (_initParams.scene && _initParams.helpers) _this._initHelpers();

    // NOTE: ==================== Autoresize. ======================

    if (_params.autoresize === 'window') {
      window.addEventListener('resize', function () {
        _this.setSize(Number(window.innerWidth * _params.resolution.width).toFixed(), Number(window.innerHeight * _params.resolution.height).toFixed());

        _this.emit('resize');
      });
    } else if (_params.autoresize) {
      window.addEventListener('resize', function () {
        // FIXME: Am I crazy or offsetHeight is increasing even when we downsize the window ?
        // console.log('height offset : ', _params.container.offsetHeight);
        _this.setSize(Number(_params.container.offsetWidth * _params.resolution.width).toFixed(), Number(_params.container.offsetHeight * _params.resolution.height).toFixed());

        _this.emit('resize');
      });
    }
    return _this;
  }

  (0, _createClass3.default)(World, [{
    key: '_initScene',
    value: function _initScene() {
      var params = this.params,
          scene = Physijs.default !== false ? new Physijs.Scene({
        fixedTimeStep: params.physics.fixedTimeStep,
        broadphase: params.physics.broadphase
      }, {
        stats: params.stats,
        world: this,
        softbody: params.softbody
      }) : new _three.Scene();

      if (Physijs.default !== false) {
        scene.setGravity(new _three.Vector3(params.gravity.x, params.gravity.y, params.gravity.z));

        scene.simulate();
        this.simulate = true;
      }

      if (params.fog.type === 'regular') scene.fog = new _three.Fog(params.fog.hex, params.fog.near, params.fog.far);else if (params.fog.type === 'exp' || params.fog.type === 'expodential') scene.fog = new _three.FogExp2(params.fog.hex, params.fog.density);

      this.importScene(scene, false);

      // Array for processing.
      this.children = [];
    }
  }, {
    key: 'addLoop',
    value: function addLoop(loop) {
      var _this2 = this;

      return new Promise(function (resolve) {
        _this2.loops.push(loop);
        resolve(loop);
      });
    }
  }, {
    key: 'removeLoop',
    value: function removeLoop(loop) {
      var _this3 = this;

      return new Promise(function (resolve) {
        _this3.loops.filter(function (l) {
          return l !== loop;
        });
        resolve(loop);
      });
    }
  }, {
    key: '_initDOM',
    value: function _initDOM() {
      var params = this.params;

      params.container.style.margin = 0;
      params.container.style.padding = 0;
      params.container.style.position = 'relative';
      params.container.style.overflow = 'hidden';

      this._dom = window.document.createElement('div');
      this._dom.className = 'whs';

      params.container.appendChild(this._dom);

      return this._dom;
    }
  }, {
    key: '_initCamera',
    value: function _initCamera() {
      var _params = this.params;

      this.camera = new _PerspectiveCamera.PerspectiveCamera({
        camera: {
          fov: _params.camera.fov,
          aspect: _params.width / _params.height,
          near: _params.camera.near,
          far: _params.camera.far
        },

        position: {
          x: _params.camera.position.x,
          y: _params.camera.position.y,
          z: _params.camera.position.z
        }
      });

      this.camera.addTo(this);
    }
  }, {
    key: '_initRendering',
    value: function _initRendering() {
      var _params = this.params;
      var computedWidth = Number(_params.width * _params.resolution.width).toFixed();
      var computedHeight = Number(_params.height * _params.resolution.height).toFixed();

      this.renderingPlugin = new _BasicRendering.BasicRendering({
        width: computedWidth,
        height: computedHeight,

        stats: _params.stats,
        init: {
          stats: _params.init.stats
        },

        background: {
          color: _params.rendering.background.color,
          opacity: _params.rendering.background.opacity
        },

        shadowmap: {
          enabled: _params.rendering.shadowmap.enabled,
          type: _params.rendering.shadowmap.type
        },

        renderer: _params.rendering.renderer
      });
    }
  }, {
    key: '_initHelpers',
    value: function _initHelpers() {
      var _params = this.params,
          _scene = this.scene;

      if (_params.helpers.axis) {
        _scene.add(new _three.AxisHelper(_params.helpers.axis.size ? _params.helpers.axis.size : 5));
      }

      if (_params.helpers.grid) {
        _scene.add(new _three.GridHelper(_params.helpers.grid.size ? _params.helpers.grid.size : 10, _params.helpers.grid.step ? _params.helpers.grid.step : 1, _params.helpers.grid.color1, _params.helpers.grid.color2));
      }
    }

    /**
     * Start animation.
     */

  }, {
    key: 'start',
    value: function start() {
      if (this._renderingPlugin) {
        this._renderingPlugin.start(this.onStartRendering.bind(this), this.onFinishRendering.bind(this));
      }
    }

    /**
     * Callback called immediately before Plugin Rendering.
     * @param  {Number} delta : delta time elapsed since the last frame.
     */

  }, {
    key: 'onStartRendering',
    value: function onStartRendering(delta) {
      this._process(delta);
      if (this.controls) this._updateControls();
      if (this.simulate) this.scene.simulate(delta, 1);
    }

    /**
     * Callback called immediately after the Plugin Rendering.
     * @param  {Number} delta : delta time elapsed since the last frame (will be equal to onStartRendering delta).
     */

  }, {
    key: 'onFinishRendering',
    value: function onFinishRendering(delta) {
      this._execLoops();
    }

    /**
     * Set the current rendering plugin for this World.
     * @param  {RenderingPlugin} renderingPlugin : The RenderingPlugin instance.
     */

  }, {
    key: '_execLoops',


    /**
     * Execute all loops with a specific time.
     *
     * @params {number} time - The time value that will be passed to loops.
     */
    value: function _execLoops() {
      for (var i = 0; i < this.loops.length; i++) {
        var e = this.loops[i];
        if (e.enabled) e.execute(e.clock);
      }
    }

    /**
     * Update controls time values.
     */

  }, {
    key: '_updateControls',
    value: function _updateControls() {
      this.controls.update(Date.now() - this.time);
      this.time = Date.now();
    }

    /**
     * Update morphs animations.
     *
     * @params {THREE.Clock} clock - The clock object, which.
     */

  }, {
    key: '_process',
    value: function _process(delta) {
      for (var i = 0; i < this.children.length; i++) {
        if (this.children[i].type === 'morph') this.children[i].native.mixer.update(delta);
      }
    }

    /**
     * This functon will scene properties when it's called.
     */

  }, {
    key: 'setSize',
    value: function setSize() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this.camera.native.aspect = width / height;
      this.camera.native.updateProjectionMatrix();

      if (this._renderingPlugin) {
        this._renderingPlugin.setSize(width, height);
      }
    }
  }, {
    key: 'importScene',
    value: function importScene(scene) {
      var _this4 = this;

      var nested = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      this.scene = scene;

      if (nested) {
        (function () {
          _this4.children = [];

          var moveChildren = function moveChildren(object) {
            for (var i = 0, max = object.children.length; i < max; i++) {
              var obj3D = object.children[i];
              var WHSobj = void 0;

              WHSobj = new _Component2.Component(obj3D);
              WHSobj.addTo(_this4);

              if (obj3D.children.length) moveChildren(obj3D, WHSobj);
            }
          };

          moveChildren(scene, _this4);
        })();
      }

      return this.scene;
    }
  }, {
    key: 'setControls',
    value: function setControls(controls) {
      var recieved = controls.integrate(this);

      this.controls = recieved instanceof Array ? recieved[0] : recieved;

      if (recieved instanceof Array && typeof recieved[1] === 'function') recieved[1](this);

      return this.controls;
    }
  }, {
    key: 'renderingPlugin',
    set: function set(plugin) {
      this._renderingPlugin = plugin(this);
    }

    /**
     * Accesor for the currently used rendering plugin.
     * @return {RenderingPlugin} The RenderingPlugin instance.
     */
    ,
    get: function get() {
      return this._renderingPlugin;
    }

    /**
     * Retrieve the renderer used by the active rendering plugin.
     * @return {THREE.WebGLRenderer} The WebGLRenderer used by the current rendering plugin.
     */

  }, {
    key: 'renderer',
    get: function get() {
      if (this._renderingPlugin) return this._renderingPlugin.renderer;
    }
  }]);
  return World;
}(_Component2.Component), _class.defaults = {
  stats: false,
  autoresize: false,
  softbody: false,

  helpers: {
    grid: false,
    axis: false
  },

  gravity: {
    x: 0,
    y: 0,
    z: 0
  },

  rendering: {
    shadowmap: {
      enabled: true,
      type: _three.PCFSoftShadowMap
    },

    background: {
      color: 0x000000,
      opacity: 1
    },

    renderer: {}
  },

  camera: {
    fov: 75,
    near: 1,
    far: 1000,

    position: {
      x: 0,
      y: 0,
      z: 0
    }
  },

  resolution: {
    width: 1,
    height: 1
  },

  physics: {
    fixedTimeStep: 1 / 60,
    broadphase: { type: 'dynamic' }
  },

  fog: {
    type: false,

    density: 0.00025,
    hex: 0x000000,
    near: 1,
    far: 1000
  },

  init: {
    scene: true,
    stats: true,
    camera: true,
    helpers: true,
    rendering: true
  }
}, _class.instructions = {
  camera: {
    position: ['x', 'y', 'z']
  },

  gravity: ['x', 'y', 'z'],

  init: ['scene', 'stats', 'camera', 'helpers', 'rendering']
}, _temp);
exports.World = World;