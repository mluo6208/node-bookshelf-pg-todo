'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeshComponent = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _three = require('three');

var _ComponentUtils = require('../utils/ComponentUtils');

var _index = require('../utils/index');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MeshComponent(targetComponent) {
  var _class, _temp;

  var resultComponent = (_temp = _class = function (_targetComponent) {
    (0, _inherits3.default)(MeshComponentEnhance, _targetComponent);

    function MeshComponentEnhance() {
      (0, _classCallCheck3.default)(this, MeshComponentEnhance);
      return (0, _possibleConstructorReturn3.default)(this, (MeshComponentEnhance.__proto__ || Object.getPrototypeOf(MeshComponentEnhance)).apply(this, arguments));
    }

    (0, _createClass3.default)(MeshComponentEnhance, [{
      key: 'g_',
      value: function g_() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.buildGeometry) {
          this.native.geometry = this.buildGeometry(this.updateParams({ geometry: params }));
        }
      }
    }, {
      key: 'm_',
      value: function m_() {
        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (this.params.material && this.params.material.kind !== params.kind) {
          this.native.material = (0, _index.loadMaterial)(this.updateParams({ material: params }).material);
        } else {
          this.updateParams({ material: params });

          for (var key in params) {
            this.native.material[key] = params[key];
          }
        }
      }

      /* Three.js */

    }, {
      key: 'raycast',
      value: function raycast() {
        var _native2;

        return (_native2 = this.native).raycast.apply(_native2, arguments);
      }
    }, {
      key: 'copy',
      value: function copy(source) {
        var sourceNative = source.native;

        if (sourceNative) {
          this.native = sourceNative.clone(source.params);
          this.params = (0, _extends3.default)({}, source.params);

          this.wrap('no-transforms');

          this.position.copy(source.position);
          this.rotation.copy(source.rotation);
          this.quaternion.copy(source.quaternion);
        } else this.params = source.params;

        this.callCopy(this);

        return this;
      }
    }, {
      key: 'wrapTransforms',
      value: function wrapTransforms() {
        var _params = this.params;

        var position = _params.position,
            rotation = _params.rotation,
            scale = _params.scale;

        this.position.set(position.x, position.y, position.z);

        this.rotation.set(rotation.x, rotation.y, rotation.z);

        this.scale.set(scale.x, scale.y, scale.z);
      }
    }, {
      key: 'clone',
      value: function clone() {
        return new resultComponent({ build: false }).copy(this);
      }
    }, {
      key: 'addHelper',
      value: function addHelper(name) {
        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var helpers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : resultComponent.helpers;

        (0, _get3.default)(MeshComponentEnhance.prototype.__proto__ || Object.getPrototypeOf(MeshComponentEnhance.prototype), 'addHelper', this).call(this, name, params, helpers);
      }
    }, {
      key: 'updateHelper',
      value: function updateHelper(name) {
        this._helpers[name].update();
      }
    }, {
      key: 'position',
      get: function get() {
        return this.native.position;
      },
      set: function set(vector3) {
        this.native.position.copy(vector3);
        return this.native.position;
      }
    }, {
      key: 'quaternion',
      get: function get() {
        return this.native.quaternion;
      },
      set: function set(quaternion) {
        this.native.quaternion.copy(quaternion);
        return this.native.quaternion;
      }
    }, {
      key: 'rotation',
      get: function get() {
        return this._native.rotation;
      },
      set: function set(euler) {
        this.native.rotation.copy(euler);
        return this.native.rotation;
      }
    }, {
      key: 'scale',
      get: function get() {
        return this.native.scale;
      },
      set: function set(vector3) {
        this.native.scale.copy(vector3);
        return this.native.scale;
      }
    }, {
      key: 'material',
      get: function get() {
        return this.native.material;
      },
      set: function set(material) {
        this.native.material = material;
      }
    }, {
      key: 'geometry',
      get: function get() {
        return this.native.geometry;
      },
      set: function set(geometry) {
        this.native.geometry = geometry;
      }
    }]);
    return MeshComponentEnhance;
  }(targetComponent), _class.defaults = (0, _index.extend)(targetComponent.defaults, {
    build: true,
    geometry: {},

    shadow: {
      cast: true,
      receive: true
    },

    material: {
      kind: 'basic'
    },

    helpers: {
      box: false,
      boundingBox: false,
      edges: false,
      faceNormals: false
    },

    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    scale: { x: 1, y: 1, z: 1 },
    target: { x: 0, y: 0, z: 0 }
  }), _class.instructions = function () {
    return targetComponent.instructions = (0, _extends3.default)({}, targetComponent.instructions, {
      position: ['x', 'y', 'z'],
      rotation: ['x', 'y', 'z'],
      scale: ['x', 'y', 'z'],
      target: ['x', 'y', 'z']
    });
  }(), _class.helpers = {
    box: [_three.BoxHelper],

    boundingBox: [_three.BoundingBoxHelper, {
      color: 0xffffff
    }, ['color']],

    edges: [_three.EdgesHelper, {
      color: 0xffffff
    }, ['color']],

    faceNormals: [_three.FaceNormalsHelper, {
      size: 2,
      color: 0xffffff,
      linewidth: 1
    }, ['size', 'color', 'linewidth']],

    vertexNormals: [_three.VertexNormalsHelper, {
      size: 2,
      color: 0xffffff,
      linewidth: 1
    }, ['size', 'color', 'linewidth']]
  }, _temp);

  (0, _ComponentUtils.$wrap)(resultComponent).onCallWrap(function (scope) {
    for (var _len = arguments.length, tags = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      tags[_key - 1] = arguments[_key];
    }

    var _native = scope.native,
        _params = scope.params,
        _helpers = _params.helpers;

    scope._helpers = {
      box: null,
      boundingBox: null,
      edges: null,
      faceNormals: null
    };

    if (tags.indexOf('no-shadows') < 0) {
      _native.castShadow = _params.shadow.cast;
      _native.receiveShadow = _params.shadow.receive;
    }

    if (_helpers.box) scope.addHelper('box');
    if (_helpers.boundingBox) scope.addHelper('boundingBox', _helpers.boundingBox);
    if (_helpers.edges) scope.addHelper('edges', _helpers.edges);
    if (_helpers.faceNormals) scope.addHelper('faceNormals', _helpers.faceNormals);
    if (_helpers.vertexNormals) scope.addHelper('vertexNormals', _helpers.vertexNormals);
  });

  return resultComponent;
}

exports.MeshComponent = MeshComponent;